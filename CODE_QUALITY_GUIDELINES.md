# РУКОВОДСТВО ПО КАЧЕСТВУ КОДА

## Общие принципы

Этот документ описывает стандарты качества кода для проекта гибридного мессенджера.

## Стиль кода

### Python
- Используем форматирование Black (max line length 88)
- Сортировка импортов через isort с профилем Black
- Используем type hints везде, где возможно
- Следуем PEP 8, за исключением E203 и W503 (несовместимы с Black)

### C++/Qt
- Используем стиль Qt для именования (camelCase для методов, PascalCase для классов)
- Используем современные возможности C++17
- Используем RAII и умные указатели
- Следуем принципам SOLID

### Dart/Flutter
- Используем стиль Dart (camelCase для переменных и методов)
- Используем линтер Effective Dart
- Пишем документацию для публичных API

## Инструменты анализа

### Форматирование
- **Black** - автоматическое форматирование Python кода
- **isort** - сортировка импортов
- **clang-format** - для C++ кода (Qt клиент)
- **dart format** - для Dart кода (Flutter клиент)

### Линтинг
- **Flake8** - проверка стиля Python кода
- **mypy** - проверка типов
- **cppcheck** - для C++ кода
- **dart analyze** - для Dart кода

### Безопасность
- **Bandit** - проверка безопасности Python кода
- **SonarQube** - комплексная проверка качества кода

## Типизация

Все функции и методы должны иметь аннотации типов:

```python
from typing import Dict, List, Optional, Union, Any
from datetime import datetime

def send_message(
    chat_id: str, 
    sender_id: int, 
    content: str, 
    message_type: str = "text",
    reply_to: Optional[str] = None
) -> Dict[str, Any]:
    """
    Отправка сообщения в чат.
    
    Args:
        chat_id: ID чата
        sender_id: ID отправителя
        content: Содержимое сообщения
        message_type: Тип сообщения (text, image, file и т.д.)
        reply_to: ID сообщения, на которое идет ответ (опционально)
    
    Returns:
        Словарь с результатом операции
    """
    # Реализация функции
    pass
```

## Документация

### Docstrings
Все публичные функции, классы и методы должны иметь docstrings в формате Google:

```python
def process_message(self, message: Dict[str, Any]) -> bool:
    """
    Обработка входящего сообщения.
    
    Args:
        message: Словарь с данными сообщения
        
    Returns:
        True если сообщение обработано успешно, иначе False
        
    Raises:
        ValueError: Если сообщение имеет неверный формат
        AuthenticationError: Если пользователь не аутентифицирован
    """
    pass
```

### Inline комментарии
Комментарии должны объяснять "почему", а не "что":

```python
# Проверяем, заблокирован ли пользователь (защита от брутфорса)
if await self.is_user_blocked(user_id):
    return False

# Используем Redis для кэширования результатов запроса
# чтобы избежать повторных обращений к базе данных
cached_result = await self.redis.get(f"chat:{chat_id}:participants")
```

## Тестирование

### Unit тесты
- Покрытие должно быть не менее 80%
- Все критические пути должны быть протестированы
- Используем pytest для тестирования

### Интеграционные тесты
- Тестирование взаимодействия между компонентами
- Тестирование API endpoints
- Тестирование базы данных

### Нагрузочные тесты
- Используем Locust для тестирования производительности
- Проверяем поведение при высокой нагрузке

## Безопасность

### Валидация данных
Все входные данные должны быть валидированы:

```python
from pydantic import BaseModel, validator

class MessageRequest(BaseModel):
    chat_id: str
    content: str
    message_type: str = "text"
    
    @validator('content')
    def validate_content(cls, v):
        if len(v) > 10000:  # Ограничение на 10KB
            raise ValueError('Сообщение слишком длинное')
        if len(v) < 1:
            raise ValueError('Сообщение не может быть пустым')
        return v
```

### Защита от атак
- Rate limiting для предотвращения DDoS
- Валидация всех входных данных
- Санитизация пользовательского ввода
- Использование подготовленных выражений для SQL

## Производительность

### Оптимизация запросов
- Использование индексов в базе данных
- Пагинация для больших наборов данных
- Кэширование часто запрашиваемых данных

### Асинхронность
- Использование asyncio для неблокирующих операций
- Правильное управление соединениями
- Использование connection pooling

## Архитектура

### Разделение ответственности
- Каждый модуль должен иметь одну четко определенную функцию
- Использование принципов SOLID
- Четкое разделение между бизнес-логикой и представлением

### Зависимости
- Минимизация зависимостей между модулями
- Использование инъекции зависимостей
- Избегать циклических зависимостей

## CI/CD практики

### Pre-commit хуки
Все изменения кода проходят через pre-commit хуки:
- Форматирование кода
- Проверка стиля
- Проверка типов
- Проверка безопасности

### Автоматические тесты
Каждый коммит запускает:
- Unit тесты
- Интеграционные тесты
- Проверки качества кода
- Проверки безопасности

## Рецензирование кода

### Pull Request требования
- Все изменения должны проходить через PR
- Необходимо как минимум одно одобрение
- Все проверки CI должны пройти
- Покрытие тестами не должно уменьшаться

### Проверки при ревью
- Соответствие стилю кода
- Наличие документации
- Покрытие тестами
- Безопасность
- Производительность